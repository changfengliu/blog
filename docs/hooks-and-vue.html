<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hooks API 在 Vue 中的实现分析 | 我的博客</title>
    <meta name="description" content="工程师改变世界">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.de31820d.css" as="style"><link rel="preload" href="/blog/assets/js/app.bc4ef9f9.js" as="script"><link rel="preload" href="/blog/assets/js/5.144c5385.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.bc45980e.js"><link rel="prefetch" href="/blog/assets/js/11.9ab16bae.js"><link rel="prefetch" href="/blog/assets/js/2.2ce49fe4.js"><link rel="prefetch" href="/blog/assets/js/3.6a70a0b9.js"><link rel="prefetch" href="/blog/assets/js/4.9e475928.js"><link rel="prefetch" href="/blog/assets/js/6.6839bb8b.js"><link rel="prefetch" href="/blog/assets/js/7.67dc841c.js"><link rel="prefetch" href="/blog/assets/js/8.bb74f765.js"><link rel="prefetch" href="/blog/assets/js/9.b7147ea8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.de31820d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">我的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/index.html" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">深入理解系列</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解JavaScript
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解CSS
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解HTML
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/blog/site/about.html" class="nav-link">About Me</a></div><div class="nav-item"><a href="https://github.com/changfengliu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/index.html" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">深入理解系列</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解JavaScript
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解CSS
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://changfengliu.github.io/css-deepen-understanding/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  深入理解HTML
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/blog/site/about.html" class="nav-link">About Me</a></div><div class="nav-item"><a href="https://github.com/changfengliu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/hooks-and-vue.html" class="active sidebar-link">Hooks API 在 Vue 中的实现分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/hooks-and-vue.html#hooks解决了什么问题" class="sidebar-link">Hooks解决了什么问题</a></li><li class="sidebar-sub-header"><a href="/blog/hooks-and-vue.html#hooks-是什么" class="sidebar-link">Hooks 是什么</a></li><li class="sidebar-sub-header"><a href="/blog/hooks-and-vue.html#hooks-api" class="sidebar-link">Hooks API</a></li></ul></li><li><a href="/blog/old/css-tricks.html" class="sidebar-link">关于CSS伪元素及伪类的使用</a></li><li><a href="/blog/old/js-ticker.html" class="sidebar-link">关于Web前端埋点的总结</a></li><li><a href="/blog/old/js-array-sort.html" class="sidebar-link">关于JavaScript Array Sort函数的坑</a></li><li><a href="/blog/old/chalk-code.html" class="sidebar-link">巧妙的属性链调用-Chalk源码解析</a></li><li><a href="/blog/old/global-image-onerror.html" class="sidebar-link">如何全局处理image onerror, 显示默认图片</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="hooks-api-在-vue-中的实现分析"><a href="#hooks-api-在-vue-中的实现分析" aria-hidden="true" class="header-anchor">#</a> Hooks API 在 Vue 中的实现分析</h1> <p>初次听到 React Hooks，是在其刚发布的那几天，网上铺天盖地的文章介绍它。看字面意思是 ‘React 钩子’，就想当然地理解应该是修改 React 组件的钩子吧。React 延伸的概念非常多，高阶组件、函数式、Render Props、Context、等等。又来了一个新概念，前端开发已经够复杂了，我心里这样想着。近两年一直用 Vue，觉得 React 的诸多特性，在 Vue 中也都有类似的解决方案，所以就没有立即去了解它。</p> <p>后来看到尤大在<a href="https://www.bilibili.com/video/av36787459/" target="_blank" rel="noopener noreferrer">Vue 3.0 最近进展<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的视频中也提到了 Hooks API，并写了一个在 <a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener noreferrer">Vue 中使用 Hooks 的 POC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。看来 Hooks 还是挺重要的，于是马上找到 React 官方文档与发布会的视频 --- 又一轮的恶补。</p> <p>看了相关资料，觉得 Hooks 的应用前景还是挺诱人的，解决了目前前端开发中的诸多痛点。不过 React Hooks 目前还在 alpha 阶段，不太完善，内置 Hooks 也不丰富。而 Vue 只有个 Hooks POC，Vue3.0 很可能会加上，但需要再等几个月。所以暂不建议在正式代码中使用。</p> <p>本篇文章着重解释一下我对 Hooks 的理解，以及 Hooks API 在 Vue 中的源码实现。也说明一下 Hooks 是个中立的概念，可以在任何框架中使用，非 React 所独有 😃</p> <h2 id="hooks解决了什么问题"><a href="#hooks解决了什么问题" aria-hidden="true" class="header-anchor">#</a> Hooks解决了什么问题</h2> <p>在开始之前，我们先复述一下 Hooks 会帮我们解决什么问题。</p> <p>按照 Dan 的说法，React 项目的开发中有以下几个痛点：</p> <ol><li>跨组件代码复用问题。</li> <li>大组件，难以维护。</li> <li>组件树层级很深。</li> <li>类组件不容易理解。</li></ol> <p>当然 Vue 项目也是一样，其实这些问题也是相关联的。</p> <p>组件化的开发方式，我们将页面拆分成不同的组件，按自上而下的数据流，层层嵌套。代码结构的最小颗粒是组件。</p> <p>如果某些组件太大，我们就继续拆分成更小的组件，然后在父组件中调用它。
如果多组件之间有不少通用逻辑，我们就用 mixin 或 构建组件的继承体系。</p> <p>但是组件拆分，会使我们很容易不小心就把组件的层级搞得很深，增加系统复杂度不说，性能也可能受到影响。并且，有些组件的交互逻辑确实比较复杂，拆分不得，系统长期迭代下来，累积的代码量很大，难以维护。</p> <p>跨组件逻辑复用更加棘手！mixin是一个双刃剑(参考：<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener noreferrer">mixin 是有害的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)；组件继承也不可取，虽然在强类型的面向对象语言(如：Java/C#)中，继承用着很好，但在 JavaScript 中总感到力不从心，也使得代码晦涩难懂；抽取 util 包也是一个惯用的做法，但如果要抽取的公用逻辑需要关联组件的本地状态呢，如果相关联的公用逻辑需要分散在组件的不同生命周期中呢，就搞不定了！这时候，我们往往就妥协了 --- 大组件/重复逻辑产生了。</p> <p>上文提到类组件的问题，虽然用面向对象的方式建模系统是很好的做法，但我个人觉得在 JavaScript 中，特别是在基于 React/Vue 组件的开发中，并不很合适，很容易出错。我们经常需要把函数 bind 到某个上下文，以确保 this 的正确指向。JavaScript 的语法过于灵活，我们知道 JavaScript 的基于静态作用域的，就是说从源码上看，就能够推断变量的作用域。但 this 是个例外，它是基于动态作用域的，就是说 this 的值是由调用者决定的。同一个方法，用不同的方式调用，其 this 指向完全不一样。感兴趣的同学，请参考：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener noreferrer">详解this<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>如何解决这些痛点呢 --- Hooks!</p> <h2 id="hooks-是什么"><a href="#hooks-是什么" aria-hidden="true" class="header-anchor">#</a> Hooks 是什么</h2> <p>wikipedia 上关于 <a href="https://en.wikipedia.org/wiki/Hooking" target="_blank" rel="noopener noreferrer">hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的定义是：</p> <blockquote><p>The term hooking covers a range of techniques used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a hook.</p></blockquote> <p>翻译成中文大体含义是：</p> <p>Hooks 包含了一系列技术，用于改变或增强操作系统、应用程序、软件组件的行为。这些技术包括拦截软件运行过程中的函数调用、消息、事件。</p> <p>对应到 React/Vue 中，Hooks 是：可以改变或增强 React/Vue 组件功能的代码模块。</p> <p>React 中强调 Hooks 只能在函数式组件中使用。本质上函数式组件就是一个单纯的渲染函数，渲染数据来源于外部，组件本身无状态 --- 这个组件的状态、生命周期中需要执行的逻辑从那里来呢? --- 由 hooks 提供。</p> <p>因此可见，Hooks 使我们模块化开发的粒度更细了，更函数式了。组件的功能变成了由 Hooks 一点点地装配起来。</p> <h2 id="hooks-api"><a href="#hooks-api" aria-hidden="true" class="header-anchor">#</a> Hooks API</h2> <p>Hooks 应该有能力侵入组件生命周期的每个环节。React 团队也希望未来 '函数式组件 + Hooks' 成为开发组件的主要方式。目前 React 提供的 Hooks 还不够丰富，后续会逐渐完善。</p> <p>这里结合 React Hooks API 与 <a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener noreferrer">尤大的Hooks POC of Vue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分析一下 Hooks API 在 Vue 中的实现。</p> <blockquote><p>React Hooks 只在 alpha 阶段，而 Vue 只是有个 Hooks POC，目前这种机制还很不完善，不建议在正式代码中使用。但 Hooks 带来的应用前景非常诱人，这里分析 Hooks 的 Vue 实现是为了更好地理解 Hooks，以及说明 Hooks 是个中立的概念，非 React 所独有(Vue3.0 很可能会加上，但需要再等几个月)。</p></blockquote> <h3 id="usestate"><a href="#usestate" aria-hidden="true" class="header-anchor">#</a> useState</h3> <p>可以为组件添加一个响应式的本地状态，及该状态相关的更新器。</p> <p>方法签名为：</p> <blockquote><p>const [state, setState] = useState(initialState);</p></blockquote> <p>setState 用于更新状态：</p> <blockquote><p>setState(newState);</p></blockquote> <p>Vue 中实现 useState:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">++</span>callIndex
  <span class="token comment">// 获取组件实例的本地状态。</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> currentInstance<span class="token punctuation">.</span>$data<span class="token punctuation">.</span>_state
  <span class="token comment">// 本地状态更新器，以自增id为键值，存储到本地状态中。</span>
  <span class="token keyword">const</span> <span class="token function-variable function">updater</span> <span class="token operator">=</span> newValue <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMounting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过$set保证其是响应式状态。</span>
    currentInstance<span class="token punctuation">.</span>$<span class="token keyword">set</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> id<span class="token punctuation">,</span> initial<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回响应式状态与更新器。</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>state<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span> updater<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码很清晰地描述了 useState 是在组件中创建了一个本地的响应式状态，并生成了一个状态更新器。</p> <p>需要注意的是：</p> <ol><li>函数 ensureCurrentInstance 是为了确保 useState 必须在 render 中执行，也就是限制了必须在函数式组件中执行。</li> <li>以 callIndex 生成的自增id作为存储状态值的key。说明 useState 需要依赖第一次渲染时的调用顺序来匹配过去的 state（每次渲染 callIndex 为重置为0）。这也限制了 useState 必须在顶层代码中使用。</li> <li>其它 hooks 也必须遵循以上两点。</li></ol> <h3 id="useeffect"><a href="#useeffect" aria-hidden="true" class="header-anchor">#</a> useEffect</h3> <p>useEffect 是为了在组件的生命周期中，执行一些带有副作用的逻辑。</p> <p>方法签名：</p> <blockquote><p>void useEffect(rawEffect, deps);</p></blockquote> <p>Vue 中实现 useEffect:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useEffect</span><span class="token punctuation">(</span>rawEffect<span class="token punctuation">,</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">++</span>callIndex
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMounting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">cleanup</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> current <span class="token punctuation">}</span> <span class="token operator">=</span> cleanup
      <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        cleanup<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token function-variable function">effect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> current <span class="token punctuation">}</span> <span class="token operator">=</span> effect
      <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cleanup<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// rawEffect的返回值，如果是一个函数的话，则定义为useEffect副作用的清理函数。</span>
        effect<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    effect<span class="token punctuation">.</span>current <span class="token operator">=</span> rawEffect
    <span class="token comment">// 在组件实例上，存储useEffect相关逻辑。</span>
    currentInstance<span class="token punctuation">.</span>_effectStore<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      effect<span class="token punctuation">,</span>
      cleanup<span class="token punctuation">,</span>
      deps
    <span class="token punctuation">}</span>
    <span class="token comment">// 组件实例mounted时，执行useEffect逻辑。</span>
    currentInstance<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'hook:mounted'</span><span class="token punctuation">,</span> effect<span class="token punctuation">)</span>
    <span class="token comment">// 组件实例destroyed时，执行useEffect相关清理逻辑。</span>
    currentInstance<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'hook:destroyed'</span><span class="token punctuation">,</span> cleanup<span class="token punctuation">)</span>
    <span class="token comment">// 若未指定依赖项或存在明确的依赖项时，当组件实例updated时，执行useEffect逻辑。</span>
    <span class="token comment">// 若指定依赖项为 [], 则useEffect只在mounted时执行一次。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps <span class="token operator">||</span> deps<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentInstance<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'hook:updated'</span><span class="token punctuation">,</span> effect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> record <span class="token operator">=</span> currentInstance<span class="token punctuation">.</span>_effectStore<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> effect<span class="token punctuation">,</span> cleanup<span class="token punctuation">,</span> deps<span class="token punctuation">:</span> prevDeps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token operator">=</span> record
    record<span class="token punctuation">.</span>deps <span class="token operator">=</span> deps
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps <span class="token operator">||</span> deps<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> d <span class="token operator">!==</span> prevDeps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 依赖的状态值有变动时，清理useEffect的副作用并重新执行。</span>
      <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// useEffect 执行完毕后，会将 current 的属性置为 null. 这里将 current 的值设置为 rawEffect，</span>
      <span class="token comment">// 是为了在 updated 时执行 useEffect 逻辑。</span>
      effect<span class="token punctuation">.</span>current <span class="token operator">=</span> rawEffect
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到 useEffect 所指定的副作用逻辑，会在组件的 mounted、updated、destroyed 三个时期执行。执行的细节由 deps 控制。</p> <p>需要注意：</p> <ol><li>如果 deps 为 null/undefined，则副作用逻辑在每次渲染都会执行。</li> <li>如果 deps 指定了依赖的状态，则相应状态改变时，会执行副作用逻辑。</li> <li>如果 deps 指定为 []，则副作用逻辑仅会在 mounted 时执行。</li> <li>每次需要执行副作用逻辑时，都会先执行清理逻辑 -- rawEffect 的返回值。</li> <li>组件 destroyed 时，会执行清理逻辑。</li></ol> <h3 id="useref"><a href="#useref" aria-hidden="true" class="header-anchor">#</a> useRef</h3> <p>相当于为组件存储一个本地变量 --- 非状态。</p> <p>方法签名：</p> <blockquote><p>const refContainer = useRef(initialValue)</p></blockquote> <p>Vue 中 useRef 的实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">++</span>callIndex
  <span class="token keyword">const</span> <span class="token punctuation">{</span> _refsStore<span class="token punctuation">:</span> refs <span class="token punctuation">}</span> <span class="token operator">=</span> currentInstance
  <span class="token keyword">return</span> isMounting <span class="token operator">?</span>
    <span class="token punctuation">(</span>refs<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      current<span class="token punctuation">:</span> initial
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span>
    refs<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="usemounted"><a href="#usemounted" aria-hidden="true" class="header-anchor">#</a> useMounted</h3> <p>添加需要在 mounted 事件中执行的逻辑。</p> <p>Vue 中 useMounted 的实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useMounted</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过 useEffect 实现，如果 deps 的值为空的话，fn 就不在 updated 中执行了 --- 即仅在 mounted 时执行一次.</p> <h3 id="usedestroyed"><a href="#usedestroyed" aria-hidden="true" class="header-anchor">#</a> useDestroyed</h3> <p>添加需要在 destroyed 阶段执行的逻辑。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useDestroyed</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面提到 useEffect 的副作用逻辑的返回值，如果是函数的话，会在 destroyed 阶段作为清理逻辑执行。
这里通过设置 deps 的值为[]，并把 fn 指定为 useEffect 的副作用逻辑的返回值，使 fn 在 destroyed 阶段执行。</p> <h3 id="useupdated"><a href="#useupdated" aria-hidden="true" class="header-anchor">#</a> useUpdated</h3> <p>添加只在组件更新后执行的逻辑。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useUpdated</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isMount <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">// 通过 useRef 生成一个标识符。</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isMount<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 跳过 mounted.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过 useEffect 实现，fn 定义在了清理逻辑的位置，每次组件更新都会执行，详细请参考 useEffect 的实现细节。</p> <h3 id="usewatch"><a href="#usewatch" aria-hidden="true" class="header-anchor">#</a> useWatch</h3> <p>为组件添加 watch.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useWatch</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMounting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentInstance<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>直接通过组件实例的 $watch 实现。</p> <h3 id="usecomputed"><a href="#usecomputed" aria-hidden="true" class="header-anchor">#</a> useComputed</h3> <p>为组件添加 computed 属性。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useComputed</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token operator">++</span>callIndex
  <span class="token keyword">const</span> store <span class="token operator">=</span> currentInstance<span class="token punctuation">.</span>_computedStore
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMounting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    store<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    currentInstance<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span>
      getter<span class="token punctuation">,</span>
      val <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        store<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> val
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        sync<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> store<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>本质上也是通过组件实例的 $watch 实现。</p> <h3 id="包装函数式组件"><a href="#包装函数式组件" aria-hidden="true" class="header-anchor">#</a> 包装函数式组件</h3> <p>把指定的渲染函数封装成 Vue 组件。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">withHooks</span><span class="token punctuation">(</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        _state<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 存储 hook state.</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 存储 hooks 相关辅助变量。</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_effectStore <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_refsStore <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_computedStore <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">render</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      callIndex <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 重置索引，以便根据调用次序匹配对应的 hooks.</span>
      currentInstance <span class="token operator">=</span> <span class="token keyword">this</span>  <span class="token comment">// 当前组件实例</span>
      isMounting <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_vnode <span class="token comment">// 标识组件的挂载状态。</span>
      <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$attrs<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$props<span class="token punctuation">)</span> <span class="token comment">// 渲染</span>
      currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">return</span> ret
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Vue 中函数式组件不多见，这里是为了模拟 React 的函数式组件。</p> <p>本质上函数式组件就是一个渲染函数，只负责渲染，渲染数据来源于外部，本身无状态 --- 相当于赤裸裸的组件。它的状态、生命周期中需要执行的逻辑从那里来呢? --- 由 hooks 提供。</p> <p>因此更直观地说明了，hooks使我们模块化的开发粒度更细了，更函数式了。组件的功能变成了由 hooks 一点点地装配起来。</p> <p>完整代码及示例请参考：<a href="https://github.com/yyx990803/vue-hooks" target="_blank" rel="noopener noreferrer">POC of vue-hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/old/css-tricks.html">
          关于CSS伪元素及伪类的使用
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/blog/assets/js/app.bc4ef9f9.js" defer></script><script src="/blog/assets/js/5.144c5385.js" defer></script>
  </body>
</html>
